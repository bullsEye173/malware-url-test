package com.cisco.security.service;

import static org.hamcrest.CoreMatchers.hasItem;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import java.util.ArrayList;
import java.util.List;

import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;

import com.cisco.security.jpa.repository.UrlJpaRepository;
import com.cisco.security.model.Url;
import com.cisco.security.model.Url.ThreatType;
import com.cisco.security.repository.UrlRepository;

public class UrlServiceTest {

	@Mock
	private UrlRepository repository;

	@Mock
	private UrlJpaRepository jpaRepository;

	@InjectMocks
	private UrlService urlService;

	private String host = "ama-alliance.com", path = "path/to/page", query = "name=ferret&color=purple";

	private String host2 = "amazon.com", path2 = "gp/bestsellers", query2 = "ref_=nav_cs_bestsellers";

	private int port = 8080, port2 = 0;

	private Url maliciousUrl, nonMaliciousUrl;

	private List<Url> maliciousUrls = new ArrayList<>();

	private List<Url> nonMaliciousUrls = new ArrayList<>();

	@Before
	public void init() {
		MockitoAnnotations.initMocks(this);
		maliciousUrl = new Url(host, port, path, query, ThreatType.MALWARE);
		maliciousUrls.add(maliciousUrl);

		nonMaliciousUrl = new Url(host2, port2, path2, query2, ThreatType.THREAT_TYPE_UNSPECIFIED);
		nonMaliciousUrls.add(nonMaliciousUrl);
	}

	@Test
	public void testGet_If_urlIsMalicious() {
		when(repository.findByHostAndPortAndPathAndQuery(host, port, path, query)).thenReturn(maliciousUrls);
		List<Url> result = urlService.find(host, port, path, query);
		assertThat(result, hasItem(maliciousUrl));
		verify(repository, times(1)).findByHostAndPortAndPathAndQuery(Mockito.anyString(), Mockito.anyInt(),
				Mockito.anyString(), Mockito.anyString());
		verify(jpaRepository, times(0)).findByHostAndPortAndPathAndQuery(Mockito.anyString(), Mockito.anyInt(),
				Mockito.anyString(), Mockito.anyString());
	}

	@Test
	public void testGet_If_urlIsNotMalicious() {
		when(repository.findByHostAndPortAndPathAndQuery(host2, port2, path2, query2)).thenReturn(new ArrayList<>());
		when(jpaRepository.findByHostAndPortAndPathAndQuery(host2, port2, path2, query2)).thenReturn(nonMaliciousUrls);
		List<Url> result = urlService.find(host2, port2, path2, query2);
		assertThat(result, hasItem(nonMaliciousUrl));
		verify(repository, times(1)).findByHostAndPortAndPathAndQuery(Mockito.anyString(), Mockito.anyInt(),
				Mockito.anyString(), Mockito.anyString());
		verify(jpaRepository, times(1)).findByHostAndPortAndPathAndQuery(Mockito.anyString(), Mockito.anyInt(),
				Mockito.anyString(), Mockito.anyString());
	}

	@Test
	public void testGetFull() {
		Url url2 = new Url("cisco.com", 0, "c/en/us/products/index.html", "", ThreatType.THREAT_TYPE_UNSPECIFIED);
		nonMaliciousUrls.add(url2);
		when(jpaRepository.findAll()).thenReturn(nonMaliciousUrls);
		List<Url> result = urlService.findAll();
		assertThat(result, hasItem(nonMaliciousUrl));
		assertThat(result, hasItem(url2));
		verify(jpaRepository, times(1)).findAll();
	}
}
